# 第三章 线程同步辅助类

[TOC]

在本章中，我们将学习如何使用更高级的同步机制来实现多线程间的同步
- 信号量(Semaphore): 是一种计数器，用来保护一个或者多个共享资源的访问。它是并发编程的一种基础工具，大多数编程语言都提供了这个机制
- CountDownLatch: 是Java语言提供的同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许线程一直等待
- CyclicBarrier: 也是Java语言提供的同步辅助类，它允许多个线程在某个集合点(common point)处进行相互等待
- Phaser: 也是Java语言提供的同步辅助类。它把并发任务分成多个阶段运行，在开始下一阶段之前，当前阶段中的所有线程都必须执行完成，这是Java7API中的新特性
- Exchanger: 也是Java语言提供的同步辅助类。它提供了两个线程之间的数据交换点

在应用程序中，任何时候都可以使用Semaphore来保护临界区，因为它是一个基础的同步机制。而其他的同步机制，则需要根据各自的上述特性来对其选择使用。所以我们需要根据应用程序的特性来选择合适的同步机制



## 1. 资源的并发访问控制

信号量（Semaphore）是一种计数器，用来保护一个或者多个共享资源的访问

如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于 0，信号量将减1，然后允许访问这个共享资源。计数器大于 0 意味着有可以使用的资源，因此线程将被允许使用其中一个资源

否则，如果信号量的计数器等于 0，信号量将会把线程置入休眠直至计数器大于 0。计数器等于 0 的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待

当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。释放操作将使信号量的内部计数器增加 1

本节中，将介绍如何使用信号量类 Semaphore 来实现二进制信号量( Binary Semaphore)。二进制信号量是一种比较特殊的信号量，用来保护对唯一共享资源的访问，因而它的内部计数器只有 0 和 1 两个值



实现一个打印队列，并发任务将使用它来完成打印。这个打印队列受二进制信号量保护，因而同时只有一个线程可以执行打印

```java
/**
 * 模拟文档打印
 * 利用信号量控制对打印机的访问
 */
public class PrintQueue {

    /**
     * 信号量控制对打印机的访问
     */
    private final Semaphore semaphore;

    /**
     * 初始化信号量
     */
    public PrintQueue() {
        semaphore = new Semaphore(1);
    }

    /**
     * 模拟打印文档的方法
     *
     * @param document 待打印的文档
     */
    public void printJob(Object document) {
        try {
            // 获取信号量的访问权限
            // 如果正在打印其他作业，则此线程将休眠，直到获得对信号量的访问权限
            semaphore.acquire();

            Long duration = (long) (Math.random() * 10);
            System.out.printf("%s: PrintQueue: Printing a Job during %d seconds\n", Thread.currentThread().getName(), duration);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 释放信号量
            // 如果有其他线程在等待此信号量，JVM会选择其中一个线程允许其访问临界区
            semaphore.release();
        }
    }

}
```



Semaphore 类还有其他两种`acquire()`方法

- acquireUninterruptibly()： 它其实就是`acquire()`方法。当信号量的内部计数器变成 0 的时候，信号量将阻塞线程直到其被释放。线程在被阻塞的这段时间中，可能会被中断，从而导致`acquire()`方法抛出`InterruptedException`异常。而`acquireUninterruptibly()`方法会忽略线程的中断并且不会抛出任何异常
- tryAcquire()： 这个方法试图获得信号量。如果能获得就返回 true；如果不能，就返回 false，从而避开线程的阻塞和等待信号量的释放。我们可以根据返回值是 true 还是 flase 来做出恰当的处理



#### 信号量的公平性

在 Java 语言中，只要一个类可能出现多个线程被阻塞并且等待同步资源的释放（例如信号量），就会涉及公平性概念。默认的模式是非公平模式。在这种模式中，被同步的资源被释放后，所有等待的线程中会有一个被选中来使用共享资源，而这个选择是没有任何条件的。公平模式则不然，它选择的是等待共享资源时间最长的那个线程

跟其他的类一样，Semaphore 类的构造器也提供了第二个传入参数。这个参数是 boolean 型的。如果传入 false 值，那么创建的信号量就是非公平模式的，与不使用这个参数的效果一样。如果传入 true 值，那么创建的信号量是公平模式的



## 2. 资源的多副本的并发访问控制



## 3. 等待多个并发事件的完成



## 4. 在集合点的同步



## 5. 并发阶段任务的运行



## 6. 并发阶段任务中的阶段切换



## 7. 并发任务间的数据交换